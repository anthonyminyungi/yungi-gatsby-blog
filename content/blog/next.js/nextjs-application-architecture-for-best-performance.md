---
title: (번역) 최고의 성능을 위한 Next.js 애플리케이션 아키텍처
date: 2023-02-28 13:07:57
category: next.js
draft: false
showToc: true
---

> 원문: [NextJs Application Architecture for best performance](https://medium.com/@sushinpv/nextjs-application-architecture-for-best-performance-8f1d22e33ba1)

---

이 글에서는 아와 같이 여러 섹션으로 구성된 Next.js 애플리케이션의 고수준 아키텍처 설계에 대해 기술합니다.

1. 초기 요청
2. Next-React 애플리케이션의 API 호출
3. 보안 계층의 인증 및 사용
4. 로드 시간 및 SEO
5. 배포 아키텍처

## 개요

개별 설계에 대해 더 깊게 알아보기 전에, 고수준에서 몇 가지 알아두어야 할 사항들이 있습니다.

![architecture-diagram](images/architecture-diagaram.png)

위 그림은 세 가지 섹션으로 구분할 수 있습니다.

1. 네트워크 계층 (요청이 애플리케이션에게 응답하는 방식)
2. Next 애플리케이션 인스턴스와 SSR
3. 외부 서비스

### 1. 네트워크 계층

이 섹션에서는 사용자가 웹사이트를 요청할 때 요청이 서버로 이동하는 방법과 사용해야 하는 프로토콜에 대해서 설명합니다.

사용자가 애플리케이션을 요청하면 요청을 로드 밸런서로 보내야 합니다.  
로드 밸런서를 통해 요청이 웹사이트 HTML 콘텐츠를 로드하기 위한 것이라면 요청을 애플리케이션 서버로 보내고, 관리자 패널에서 업로드한 이미지, 빌드 파일, 폰트 등과 같은 정적 콘텐츠를 로드하기 위한 요청인 경우에는 요청을 CDN으로 보내고 컨텐츠를 CDN에서 로드해야 합니다.

이러한 방식으로 우리는 엣지 로케이션에서 모든 정적 콘텐츠를 전달할 수 있을 것이며, 애플리케이션 서버의 정적 부하 요청을 줄일 수 있을 것입니다.

두 경우 모두 HTTP/2 또는 HTTP/3를 사용해야 하며, HTTP/2보다 HTTP/3이 더 선호됩니다.

### 2. Next 애플리케이션 인스턴스와 SSR

이 섹션에서는 애플리케이션 코드와 작동 방식에 대해 설명합니다.  
모든 요청은 들어오는 어떤 요청이든 캐싱하는 next-boost 캐시 커스텀 서버를 거치게 됩니다.  
next-boost를 사용하는 이유는 SQLite 데이터베이스에서 실행되는 고성능 라이브러리이기 때문입니다.  
결과적으로 처리량이 매우 높으며, 이 계층을 쉽게 구성할 수 있습니다.  
요청은 주로 서로 다른 5가지 유형의 요청으로 구성됩니다.

1. 페이지 요청은 대부분 Next 애플리케이션이 모든 리소스들을 로드하고 요청된 페이지의 HTML 단계의 페이지를 생성하는 SSR 요청입니다.  
   HTML과 함께 로드할 동적 데이터가 필요한 경우 Next.js의 메소드 중 하나인 `getServerSideProps`를 사용해야 합니다.

2. 이 요청은 사용자가 한 페이지에서 다른 페이지로 변경할 때 만들어지며, 두 번째 페이지에 `getServerSideProps`가 포함되어 있으면 이 요청이 만들어집니다.  
   next-boost는 이 요청을 캐싱하지 않으므로 이러한 코드를 위해 redis 캐시와 같은 자체 캐시 레이어가 필요합니다.

3. Next의 API 요청은 Next.js API 정의에 대한 요청이며, 플랫폼이 대부분의 경우 브라우저 수준에서 요청하기 때문에 특수한 케이스가 아니면 일반적으로는 이 계층을 캐싱할 필요가 없습니다.

4. 웹사이트에 로드되는 모든 사진에 대해 `next/image`를 사용해야 합니다.  
   Next Image는 인터넷을 통한 전송 시간을 최소화하기 위해 이미지를 특정 크기와 형식으로 트랜스코딩하는 로더입니다.  
   여기에서 next-boost 캐시를 활성화하고 대부분의 webp 및 avip 형식의 이미지를 지정할 수 있습니다.

5. 파일 요청은 동적으로 정적인 콘텐츠를 제공해야 하는 경우가 아니면 필요하지 않습니다.  
   이전에 언급했듯이 모든 정적 콘텐츠는 CDN으로 이동되므로 이 경로가 필요하지 않습니다.  
   그러나 매우 동적이고 정기적으로 자동 업데이트되는 사이트맵을 제공해야 하는 경우에는 웹사이트 자체와 함께 저장해야 할 수도 있습니다.  
   이러한 경우에 이 경로를 사용할 수 있습니다.

### 3. 외부 서비스

여기에는 우리가 사용하는 모든 외부 서비스, 예를 들어 DB 엔진, redis 및 기타 Google 클라우드 서비스 등이 포함됩니다.

## 초기 요청

브라우저와 관련된 단계는 아래와 같습니다.

1. HTML 마크업

   1. 사용자가 웹사이트 URL을 입력하면 브라우저는 첫 번째 초기 페이지 요청을 보냅니다.
   2. 로드 밸런서가 그 요청을 수신합니다.
   3. 로드 밸런서는 요청을 사용자 지정 서버의 Next 애플리케이션으로 라우팅합니다.
   4. 파일이 이미 캐싱된 경우 사용자 지정 서버는 파일을 확인하고 캐싱된 데이터를 반환합니다.
   5. 그렇지 않은 경우 Next 애플리케이션을 로드하고 `GetServerSideProps`와 같은 Next 서버 실행 파일을 실행한 다음 전체 Next 애플리케이션을 로드하고 마지막으로 이 페이지를 HTML로 변환합니다.
   6. 파싱된 HTML을 캐싱합니다.
   7. 클라이언트로 해당 데이터를 반환합니다.

2. 후속 호출

   1. HTML 마크업이 다운로드되어 브라우저에 로드됩니다.
   2. 이후 CSS, JS, 폰트, 이미지 등과 같은 모든 필수 파일들을 로드하라는 요청을 보냅니다.
   3. 로드 밸런서가 이 요청을 수신합니다.
   4. 그 다음 로드 밸런서는 이 요청을 CDN과 같이 파일이 보관되는 스토리지 버킷으로 보냅니다.
   5. 애플리케이션 로드밸런서를 우회하여 하위 도메인을 구축하고, CDN을 Storage Bucket에 직접 연결할 수 있습니다.
   6. 웹사이트에서 react가 모두 로드되면 클라이언트에서 초기화됩니다.
   7. 동적 로딩을 위해 프론트엔드 API 호출이 필요한 경우 react는 호출을 수행하고 데이터를 redux에 저장합니다.

   ![next-flow](images/next-flow.png)

3. Next 페이지 로딩

   1. 사용자가 페이지 A에서 페이지 B로 이동할 떄 두 번째 페이지를 초기화하는 데 필요한 JavaScript가 미리 로드되고, `getServerSideProps`를 가져오기 위한 API 요청이 생성됩니다.
   2. API 요청이 성공하면 다른 모든 동적 JavaScript 콘텐츠와 함께 두 번째 페이지가 표시됩니다.
   3. JavaScript 외에도 시스템은 페이지 B에 필요한 이미지 및 정적 콘텐츠를 로드하도록 요청합니다.

   ![load-next-page](images/load-next-page.png)

## Next-React 애플리케이션의 API 호출

API 호출에는 크게 세 가지 유형이 있습니다.

### SSR API 호출

SSR API 호출(`GetServerSideProps`)을 최적화해야 하는 이유는, 자칫하면 애플리케이션의 단일 실패 지점이 될 수 있기 때문입니다.  
즉, 직접 링크나 프론트엔드 라우팅이 있는 모든 페이지 방문에 대해 Next.js는 자동으로 API를 호출하여 `getServerSideProps`를 가져옵니다.  
즉, 1000명이 웹사이트를 방문하면 불필요하게 서버 부하가 증가하게 되는 것입니다.

![ssr](images/ssr.png)

모든 `getServerSideProps` 요청은 먼저 redis 캐시를 기반으로 하는 캐시 계층으로 이동해 API가 이미 캐싱되었는지 여부를 확인합니다.  
API가 캐싱되어 있다면 간단히 데이터를 반환할 수 있으며, API가 캐시되지 않은 경우에 이 요청은 API 계층으로 이동해 외부 API를 호출하고 데이터를 검색합니다.  
마지막으로 이 요청에 대한 응답이 프론트엔트로 전송됩니다. 이 방법을 사용하게 되면 하나의 요청만 처리하면 됩니다.

### Redux 기반 API 호출

이 섹션을 이해하려면 먼저 두 가지 질문을 제기해야 합니다.

- Redux가 왜 필요할까?
- 왜 react-query나 다른 라이브러리를 사용해 API 호출할 수 없을까?

이 문제에 대한 해답은 Redux가 단순한 API 호출 이상의 용도로 사용된다는 것입니다.  
또한 Redux는 전체 애플리케이션 상태와 캐싱 및 수정이 필요한 API 호출을 처리하는 데에 사용됩니다.

예를 들어, 페이지에서 전체 사용자가 만든 모든 콘텐츠를 로드해야 하고, 사용자의 선택에 따라 항목을 정렬해야 할 수도 있을 것입니다.  
이 경우 전체 데이터를 프론트엔드에 로드하고 컴포넌트로 가져오기 전에 redux 저장소에서 직접 데이터를 정렬할 수 있습니다.

Redux와 함께 사용할 수 있는 구조는 다음과 같습니다. (상태는 세 가지 영역으로 나뉩니다.)

1. 인증(Auth): 모든 인증 정보를 저장하기 위해
2. 엔티티(Entities): 로컬 상태와 서버 상태를 동시에 추가하고 변경할 수 있도록 서버 표현 데이터(Representation Data)를 저장하기 위해
3. UI: 모든 UI 관련 상태를 추적하기 위해

![redux](images/redux-api.png)

API 호출을 하려면 컴포넌트가 모두 API 호출 여부를 결정하는 각각의 액션 생성자(Action Creator)를 거쳐야 합니다.  
데이터를 사용할 수 있다면 다시 API를 호출할 필요가 없습니다.

데이터를 사용할 수 없는 경우, 액션 생성자는 API 이벤트를 보내고, API 계층(API Layer)에서는 이를 인터셉트하여 API 호출을 수행하고 적절한 리듀서(Reducer)를 실행하는 데 사용할 것입니다.

리듀서는 저장소 내의 데이터를 처리해서 반환값에 기록합니다.

컴포넌트는 셀렉터(Selectors)를 사용하여 저장소 내에 정의된 redux에서 데이터를 읽어오고 컴포넌트로 반환되기 전에 데이터를 변경할 수 있습니다.

Redux 기반 접근 방식의 또 다른 이점은 API를 사용할 컴포넌트가 로드되기 전에 API를 미리 로드(Preload)할 수 있다는 것입니다.  
우리는 그저 액션 생성자를 호출하기만 하면 됩니다.

> Redux는 중앙화된 상태관리의 강력함을 가지고 있어 데이터에 대한 어떤 변경사항이 발생하더라도 리스너가 자동으로 업데이트됩니다.

### 직접, 혹은 캐시된 API 호출

직접적인 API 호출은 왜 필요할까요?
Redux 안에 데이터를 저장하고 재사용하고자 하는 경우가 아니라면, Redux를 통해 모든 API를 호출을 수행하는 것은 권장되지 않습니다.  
따라서, 우리는 Redux에 데이터를 저장하고 이를 재사용하려는 목적이 아니라면 Redux를 통해 API 호출을 할 필요가 없습니다.

이러한 상황에서는 직접 API 호출을 사용하게 됩니다.

![direct-api-call](./images/direct-api-call.png)

## 보안 계층의 인증 및 사용

인증 정보를 쿠키나 브라우저 로컬 스토리지(LocalStorage)에 직접 저장하는 방식은 SPA를 다룰 때 많은 이들이 흔히 저지르는 실수지만, 이러한 방식의 문제는 공격자가 이 정보를 매우 빠르게 훔칠 수 있다는 것입니다.

이 문제를 해결하기 위한 최고의 해결책은 **암호화된** 로컬 스토리지에 저장하는 것입니다. 그러나, 모든 디바이스에 대한 저장 키로 데이터를 암호화하게 되면 공격자는 로컬 스토리지 또는 쿠키 정보를 한 브라우저에서 다른 브라우저로 복사할 수 있으며 동일한 애플리케이션을 실행하는 다른 브라우저에서 데이터를 해독할 수 있게 됩니다. 이는 해결해야 하는 또 다른 문제입니다.

이 문제를 해결하기 위해서는 암호화된 브라우저에서만 볼 수 있는 안전한 데이터 저장 방법을 사용해야 합니다. 이를 가능하게 하기 위해서는 먼저 각 브라우저에 대해 고유한 키를 생성한 다음, 해당 키를 사용해서 복호화해야 합니다. 이를 위해 브라우저의 지문 키(fingerprint key)를 암호화 키로 활용하고 데이터를 보존할 수 있습니다.

### API 계층의 보안

이는 프론트엔드에 있어 필수 사항은 아니지만, 전체 API가 악용되지 않도록 보호하기 위해서 필요합니다. 일반적으로, 사용자가 인증 토큰을 받으면 해당 토큰을 사용해 접근할 수 있는 모든 경로에 대해 요청을 보낼 수 있습니다.

이 문제를 해결하기 위해 클라이언트와 서버가 각 요청에 대해 해시 키를 공유하는 보안 환경을 설정할 수 있습니다.

![api-hash](./images/api-hash.png)

API 계층은 총 네 단게로 구성되며, 첫 번째 단계는 요청 URL을 생성하고 요청 매개변수를 정의하는 API 생성기(Generator)입니다.

두 번째 단계는 이러한 모든 인수를 사용하여 요청 객체를 만드는 것입니다. 일반적으로 요청객체에는 아래에 나열된 필드가 포함됩니다.

1. URL
2. Method
3. Body
4. Header
5. User-Agent / 브라우저 지문(fingerprint)
6. Authorization Token (인증 토큰)

다음 단계에서는 요청 객체를 통해 보안 키를 사용해서 해시 키를 생성하고 실제 요청의 헤더에 필드를 추가한 뒤,

마지막 단계에서는 데이터를 서버로 보내고 동일한 로직을 사용해 서버에서 또 해시 키를 생성하는 것입니다.

공격자는 각 요청의 해시 키가 모든 브라우저와 사용자에 대해 고유하기 때문에 시스템을 공격하기 위해 유출된 토큰을 사용할 수 없으며 애플리케이션만이 유일하게 보안 키를 사용하여 이 해시 키를 생성할 수 있습니다. 따라서 토큰이 유출되더라도 공격자는 시스템을 악용할 수 없게 됩니다.

## 로드 시간 및 SEO

Next.js를 사용하는 주된 이유는 보통 SEO를 기본적으로 지원하기 위해서입니다. 이런 경우 우리는 SEO 및 로드 시간을 향상시킬 방법을 찾게 됩니다.

1. 서드 파티 라이브러리
   서드 파티 라이브러리를 로드하려면 Next.js의 `<Script>` 태그와 함께 다른 전략을 사용해서 컨텐츠가 로드되기 전에 필요한 라이브러리들을 로드합니다. 다른 모든 라이브러리는

## 배포 아키텍처
